<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>认证 on My New Hugo Site</title><link>https://blahvalf.github.io/docs/information/software/cloud/auth/</link><description>Recent content in 认证 on My New Hugo Site</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://blahvalf.github.io/docs/information/software/cloud/auth/index.xml" rel="self" type="application/rss+xml"/><item><title>ServiceAccount</title><link>https://blahvalf.github.io/docs/information/software/cloud/auth/serviceaccount/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blahvalf.github.io/docs/information/software/cloud/auth/serviceaccount/</guid><description>&lt;p>ServiceAccount 为 Pod 中的进程提供身份信息。&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>：&lt;strong>本文是关于 Service Account 的用户指南，管理指南另见 Service Account 的集群管理指南 。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>本文档描述的关于 Service Account 的行为只有当您按照 Kubernetes 项目建议的方式搭建起集群的情况下才有效。您的集群管理员可能在您的集群中有自定义配置，这种情况下该文档可能并不适用。&lt;/p>&lt;/blockquote>
&lt;p>当您（真人用户）访问集群（例如使用&lt;code>kubectl&lt;/code>命令）时，apiserver 会将您认证为一个特定的 User Account（目前通常是&lt;code>admin&lt;/code>，除非您的系统管理员自定义了集群配置）。Pod 容器中的进程也可以与 apiserver 联系。 当它们在联系 apiserver 的时候，它们会被认证为一个特定的 Service Account（例如&lt;code>default&lt;/code>）。&lt;/p>
&lt;h2 id="使用默认的-service-account-访问-api-server">使用默认的 Service Account 访问 API server &lt;a href="#%e4%bd%bf%e7%94%a8%e9%bb%98%e8%ae%a4%e7%9a%84-service-account-%e8%ae%bf%e9%97%ae-api-server" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>当您创建 pod 的时候，如果您没有指定一个 service account，系统会自动得在与该pod 相同的 namespace 下为其指派一个&lt;code>default&lt;/code> service account。如果您获取刚创建的 pod 的原始 json 或 yaml 信息（例如使用&lt;code>kubectl get pods/podename -o yaml&lt;/code>命令），您将看到&lt;code>spec.serviceAccountName&lt;/code>字段已经被设置为 &lt;code>default&lt;/code>。&lt;/p>
&lt;p>您可以在 pod 中使用自动挂载的 service account 凭证来访问 API，如 &lt;a href="https://kubernetes.io/docs/user-guide/accessing-the-cluster/#accessing-the-api-from-a-pod" rel="external" target="_blank">Accessing the Cluster&lt;svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">&lt;path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/>&lt;/svg>&lt;/a> 中所描述。&lt;/p></description></item><item><title>RBAC</title><link>https://blahvalf.github.io/docs/information/software/cloud/auth/rbac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blahvalf.github.io/docs/information/software/cloud/auth/rbac/</guid><description>&lt;p>&lt;strong>注意：本文基于 Kubernetes 1.6 撰写，当时 RBAC 模式处于 beta 版本。&lt;/strong>&lt;/p>
&lt;p>基于角色的访问控制（Role-Based Access Control，即”RBAC”）使用 &lt;code>rbac.authorization.k8s.io&lt;/code> API Group 实现授权决策，允许管理员通过 Kubernetes API 动态配置策略。&lt;/p>
&lt;p>要启用 RBAC，请使用 &lt;code>--authorization-mode=RBAC&lt;/code> 启动 API Server。&lt;/p>
&lt;h2 id="api-概述">API 概述 &lt;a href="#api-%e6%a6%82%e8%bf%b0" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>本节将介绍 RBAC API 所定义的四种顶级类型。用户可以像使用其他 Kubernetes API 资源一样 （例如通过 &lt;code>kubectl&lt;/code>、API 调用等）与这些资源进行交互。例如，命令 &lt;code>kubectl create -f (resource).yml&lt;/code> 可以被用于以下所有的例子，当然，读者在尝试前可能需要先阅读以下相关章节的内容。&lt;/p>
&lt;h3 id="role-与-clusterrole">Role 与 ClusterRole &lt;a href="#role-%e4%b8%8e-clusterrole" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>在 RBAC API 中，一个角色包含了一套表示一组权限的规则。 权限以纯粹的累加形式累积（没有” 否定” 的规则）。 角色可以由命名空间（namespace）内的 &lt;code>Role&lt;/code> 对象定义，而整个 Kubernetes 集群范围内有效的角色则通过 &lt;code>ClusterRole&lt;/code> 对象实现。&lt;/p>
&lt;p>一个 &lt;code>Role&lt;/code> 对象只能用于授予对某一单一命名空间中资源的访问权限。 以下示例描述了”default” 命名空间中的一个 &lt;code>Role&lt;/code> 对象的定义，用于授予对 pod 的读访问权限：&lt;/p>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="0dc4f9a" class="language-yaml ">
 &lt;code>kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
 namespace: default
 name: pod-reader
rules:
- apiGroups: [&amp;#34;&amp;#34;] # 空字符串&amp;#34;&amp;#34; 表明使用 core API group
 resources: [&amp;#34;pods&amp;#34;]
 verbs: [&amp;#34;get&amp;#34;, &amp;#34;watch&amp;#34;, &amp;#34;list&amp;#34;]&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;p>&lt;code>ClusterRole&lt;/code> 对象可以授予与 &lt;code>Role&lt;/code> 对象相同的权限，但由于它们属于集群范围对象， 也可以使用它们授予对以下几种资源的访问权限：&lt;/p></description></item><item><title>NetworkPolicy</title><link>https://blahvalf.github.io/docs/information/software/cloud/auth/networkpolicy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blahvalf.github.io/docs/information/software/cloud/auth/networkpolicy/</guid><description>&lt;p>网络策略说明一组 &lt;code>Pod&lt;/code> 之间是如何被允许互相通信，以及如何与其它网络 Endpoint 进行通信。 &lt;code>NetworkPolicy&lt;/code> 资源使用标签来选择 &lt;code>Pod&lt;/code>，并定义了一些规则，这些规则指明允许什么流量进入到选中的 &lt;code>Pod&lt;/code> 上。关于 Network Policy 的详细用法请参考 &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" rel="external" target="_blank">Kubernetes 官网&lt;svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">&lt;path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/>&lt;/svg>&lt;/a>。&lt;/p>
&lt;p>Network Policy 的作用对象是 Pod，也可以应用到 Namespace 和集群的 Ingress、Egress 流量。Network Policy 是作用在 L3/4 层的，即限制的是对 IP 地址和端口的访问，如果需要对应用层做访问限制需要使用如 &lt;a href="https://istio.io" rel="external" target="_blank">Istio&lt;svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">&lt;path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/>&lt;/svg>&lt;/a> 这类 Service Mesh。&lt;/p></description></item><item><title>SPIFFE</title><link>https://blahvalf.github.io/docs/information/software/cloud/auth/spiffe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blahvalf.github.io/docs/information/software/cloud/auth/spiffe/</guid><description>&lt;p>SPIFFE，即每个人的安全生产身份框架（Secure Production Identity Framework for Everyone），是一套开源标准，用于在动态和异构环境中安全地进行身份识别。采用 SPIFFE 的系统无论在哪里运行，都可以轻松可靠地相互认证。&lt;/p>
&lt;p>SPIFFE 开源规范的核心是——通过简单 API 定义了一个短期的加密身份文件 SVID。然后，工作负载进行认证时可以使用该身份文件，例如建立 TLS 连接或签署和验证 JWT 令牌等。&lt;/p>
&lt;p>SPIFFE 已经在云原生应用中得到了大量的应用，尤其是在 &lt;a href="../usecases/istio.md">Istio&lt;/a> 和 &lt;a href="../usecases/envoy.md">Envoy&lt;/a> 中。下面将向你介绍 SPIFFE 的一些基本概念。&lt;/p>
&lt;h2 id="工作负载">工作负载 &lt;a href="#%e5%b7%a5%e4%bd%9c%e8%b4%9f%e8%bd%bd" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>工作负载是个单一的软件，以特定的配置部署，用于单一目的；它可能包括软件的多个运行实例，所有这些实例执行相同的任务。工作负载这个术语可以包含一系列不同的软件系统定义，包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一个运行 Python 网络应用程序的网络服务器，在一个虚拟机集群上运行，前面有一个负载均衡器。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个 MySQL 数据库的实例。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个处理队列中项目的 worker 程序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>独立部署的系统的集合，它们一起工作，例如一个使用数据库服务的网络应用程序。网络应用程序和数据库也可以单独被视为工作负载。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>就 SPIFFE 而言，工作负载往往比物理或虚拟节点更加细化——通常细化到节点上的单个进程。这对工作负载来说至关重要，例如，在容器编排器中托管的工作负载，几个工作负载可能在同一个节点上（但彼此隔离）。&lt;/p>
&lt;p>就 SPIFFE 而言，一个工作负载也可能跨越许多节点。例如，一个可弹性扩展的网络服务器可能同时运行在许多机器上。&lt;/p>
&lt;p>虽然工作负载的粒度会因环境而异，但就 SPIFFE 而言，我们&lt;strong>假设&lt;/strong>工作负载之间有足够好的隔离，这样恶意的工作负载就不能窃取他人的凭证。这种隔离的稳健性和实现的机制超出了 SPIFFE 的范围。&lt;/p>
&lt;h2 id="spiffe-id">SPIFFE ID &lt;a href="#spiffe-id" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>SPIFFE ID 是一个字符串，可以唯一地、具体地标识一个工作负载。SPIFFE ID 也可以分配给工作负载所运行的中间系统（如一组虚拟机）。例如，&lt;code>spiffe://acme.com/billing/payments&lt;/code> 是一个有效的SPIFFE ID。&lt;/p>
&lt;p>SPIFFE ID 是一个&lt;a href="https://tools.ietf.org/html/rfc3986" rel="external" target="_blank">统一资源标识符（URI&lt;svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">&lt;path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/>&lt;/svg>&lt;/a>），其格式如下：&lt;code>spiffe://信任域/工作负载标识符&lt;/code>。&lt;/p></description></item></channel></rss>