<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>云原生 on My New Hugo Site</title><link>https://blahvalf.github.io/docs/information/software/cloud/</link><description>Recent content in 云原生 on My New Hugo Site</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://blahvalf.github.io/docs/information/software/cloud/index.xml" rel="self" type="application/rss+xml"/><item><title>K8s架构</title><link>https://blahvalf.github.io/docs/information/software/cloud/k8s_arch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blahvalf.github.io/docs/information/software/cloud/k8s_arch/</guid><description>&lt;h1 id="系统架构">系统架构 &lt;a href="#%e7%b3%bb%e7%bb%9f%e6%9e%b6%e6%9e%84" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;p>Kubernetes 最初源于谷歌内部的 Borg，提供了面向应用的容器集群部署和管理系统。Kubernetes 的目标旨在消除编排物理 / 虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。Kubernetes 也提供稳定、兼容的基础（平台），用于构建定制化的 workflows 和更高级的自动化任务。 Kubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。Kubernetes 还提供完善的管理工具，涵盖开发、部署测试、运维监控等各个环节。&lt;/p>
&lt;p>Kubernetes 借鉴了 Borg 的设计理念，比如 Pod、Service、Label 和单 Pod 单 IP 等。Kubernetes 的整体架构跟 Borg 非常像，如下图所示。&lt;/p>
&lt;pre class="mermaid">graph TD
 subgraph 外部用户
 K[kubectl]
 end

 subgraph Master节点
 A[API Server&amp;lt;br/&amp;gt;REST模式]
 AD[Admission&amp;lt;br/&amp;gt;校验/变更]
 S[Storage&amp;lt;br/&amp;gt;etcd]
 CM[Controller Manager]
 SCH[Scheduler]
 end

 subgraph Node节点
 K1[kubelet]
 K2[kubelet]
 P1[Pod]
 P2[Pod]
 C1[Container]
 C2[Container]
 C3[Container]
 end

 网络((Internet)) --&amp;gt; FW[Firewall]
 FW --&amp;gt; PR[Proxy]
 
 K -- 认证请求 --&amp;gt; A
 A &amp;lt;-- Valid &amp;amp; Mutex --&amp;gt; AD
 A -- 存储 --&amp;gt; S

 CM &amp;lt;-- 监听/读写/资源变更 --&amp;gt; A
 A &amp;lt;-- 读写/调度 --&amp;gt; SCH

 
 A &amp;lt;-- 获取状态/更新状态 --&amp;gt; K1
 K1 --&amp;gt; P1 --&amp;gt; C1 &amp;amp; C2
 K1 --&amp;gt; P2 --&amp;gt; C3

 PR -. 流量代理 .-&amp;gt; P1
 PR -. 流量代理 .-&amp;gt; P2

 classDef master fill:#f9f,stroke:#333;
 classDef node fill:#ccf,stroke:#333;
 classDef pod fill:#cff,stroke:#333;
 class K1,K2,PR node;
 class A,AD,S,CM,SCH master;
 class P1,P2 pod;
&lt;/pre>
&lt;p>Kubernetes 主要由以下几个核心组件组成：&lt;/p></description></item><item><title>资源超卖</title><link>https://blahvalf.github.io/docs/information/software/cloud/resource_oversold/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blahvalf.github.io/docs/information/software/cloud/resource_oversold/</guid><description>&lt;h1 id="背景">背景 &lt;a href="#%e8%83%8c%e6%99%af" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h1>&lt;h2 id="what">What &lt;a href="#what" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>&lt;strong>资源超卖（Oversubscription）&lt;/strong> 是指在计算资源（如CPU、内存）的分配过程中，系统承诺给用户或工作负载的资源总量 &lt;strong>超过实际可用的物理资源&lt;/strong>。这一概念类似于航空公司的机票超售：飞机座位是有限的，但通过统计分析和历史数据预测，航空公司可以卖出略多于实际容量的机票，因为通常会有部分乘客改签或取消行程。&lt;/p>
&lt;p>在Kubernetes（k8s）中，超卖通常表现为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>资源请求（Requests）总和 &amp;lt; 节点实际资源&lt;/strong>&lt;br>
例如：一个节点有16核CPU，但所有Pod的CPU请求总和为20核。&lt;/li>
&lt;li>&lt;strong>资源限制（Limits）总和 &amp;raquo; 节点实际资源&lt;/strong>&lt;br>
例如：节点内存为64GB，但所有Pod的内存限制总和达到80GB。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>为什么能实现超卖？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>资源使用具有波动性&lt;/strong>
&lt;ul>
&lt;li>大多数应用不会始终满负荷运行（如Web服务在夜间流量低谷时CPU利用率可能低于10%）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>时间片复用（CPU）&lt;/strong>
&lt;ul>
&lt;li>CPU是时分复用资源，超卖的Pod通过分时共享物理核心。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>内存超卖的投机性&lt;/strong>
&lt;ul>
&lt;li>依赖“并非所有Pod会同时满负荷使用内存”的假设，但风险较高（可能触发OOM Kill）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>超卖 vs 资源过度分配（Overcommitment）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>超卖&lt;/strong> 是主动行为，目的是提高资源利用率，通常伴随监控和兜底机制。&lt;/li>
&lt;li>&lt;strong>过度分配&lt;/strong> 可能是无意识的配置错误，容易导致系统不稳定。&lt;/li>
&lt;/ul>



 
 
 

 
 
 
 

 

 &lt;div class="prism-codeblock ">
 &lt;pre id="d29c674" class="language-yaml ">
 &lt;code># 一个超卖CPU的Pod配置示例：
resources:
 requests:
 cpu: &amp;#34;0.5&amp;#34; # 调度器按此值分配
 limits:
 cpu: &amp;#34;2&amp;#34; # 实际可突发使用2核（如果节点有空闲）&lt;/code>
 &lt;/pre>
 &lt;/div>
&lt;h2 id="why">Why &lt;a href="#why" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>&lt;strong>1. 提升集群资源利用率&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>现实问题&lt;/strong>：大多数Kubernetes集群的&lt;strong>平均资源利用率不足50%&lt;/strong>（尤其是CPU），大量资源因“预留”而闲置。&lt;/li>
&lt;li>&lt;strong>超卖的作用&lt;/strong>：
&lt;ul>
&lt;li>允许更多Pod运行在相同节点上，充分利用资源空闲时段。&lt;/li>
&lt;li>例如：一个16核的节点，若所有Pod的&lt;code>requests&lt;/code>总和为10核，超卖后实际运行20核的负载（利用时间片复用）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. 降低成本&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>云环境成本优化&lt;/strong>：减少为“峰值负载”预留的节点数量，直接降低云厂商计费（如AWS EC2实例费用）。&lt;/li>
&lt;li>&lt;strong>裸金属服务器场景&lt;/strong>：通过超卖推迟硬件扩容，降低CAPEX（资本支出）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>3. 支持弹性业务需求&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>突发流量处理&lt;/strong>：互联网服务的流量具有潮汐特征（如电商大促），超卖允许Pod临时突破&lt;code>requests&lt;/code>限制，快速响应请求。&lt;/li>
&lt;li>&lt;strong>批处理任务&lt;/strong>：AI训练、日志分析等短时高负载任务，可通过超卖“见缝插针”式调度，避免排队等待。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>4. 开发/测试环境效率&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>低优先级负载容忍超卖&lt;/strong>：开发环境的Pod通常不需要严格SLA，超卖可让单节点运行更多测试容器，加速CI/CD流程。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>背后的经济学原理&lt;/strong>&lt;br>
超卖本质是&lt;strong>通过风险交换效率&lt;/strong>，其可行性依赖两个统计规律：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>负载不重合性&lt;/strong>：不同业务的峰值时间错开（如白天在线服务、夜间批处理任务）。&lt;/li>
&lt;li>&lt;strong>局部性原理&lt;/strong>：多数应用的实际资源使用量长期低于其&lt;code>requests&lt;/code>（如某服务声明需要4核，但实际平均使用1核）。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>典型案例&lt;/strong>&lt;/p></description></item><item><title>Cluster Autoscaler</title><link>https://blahvalf.github.io/docs/information/software/cloud/autoscale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blahvalf.github.io/docs/information/software/cloud/autoscale/</guid><description>&lt;h2 id="1-什么是-cluster-autoscaler">&lt;strong>1. 什么是 Cluster Autoscaler？&lt;/strong> &lt;a href="#1-%e4%bb%80%e4%b9%88%e6%98%af-cluster-autoscaler" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>&lt;strong>Kubernetes Cluster Autoscaler（CA）&lt;/strong> 是一个开源的 Kubernetes 组件，用于 &lt;strong>自动调整集群的节点数量&lt;/strong>，以确保 Pod 能够被高效调度，同时优化资源利用率，降低成本。&lt;/p>
&lt;h3 id="核心功能">&lt;strong>核心功能&lt;/strong> &lt;a href="#%e6%a0%b8%e5%bf%83%e5%8a%9f%e8%83%bd" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>自动扩容&lt;/strong>：当 Pod 因资源不足无法调度时，自动增加节点。&lt;/li>
&lt;li>&lt;strong>自动缩容&lt;/strong>：当节点利用率过低时，安全移除空闲节点。&lt;/li>
&lt;li>&lt;strong>多云支持&lt;/strong>：兼容 AWS、GCP、Azure、阿里云、腾讯云等主流云平台。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="2-为什么需要-cluster-autoscaler">&lt;strong>2. 为什么需要 Cluster Autoscaler？&lt;/strong> &lt;a href="#2-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-cluster-autoscaler" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;p>在 Kubernetes 集群中，Pod 的负载通常是动态变化的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>突发流量&lt;/strong>：业务高峰时，需要快速扩容节点以承载更多 Pod。&lt;/li>
&lt;li>&lt;strong>资源浪费&lt;/strong>：低峰期时，部分节点可能闲置，但仍需支付费用。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>手动管理节点的问题&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>响应慢&lt;/strong>：人工调整节点数量无法应对突发流量。&lt;/li>
&lt;li>&lt;strong>成本高&lt;/strong>：固定节点数量可能导致资源浪费或不足。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Cluster Autoscaler 的解决方案&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>自动化&lt;/strong>：根据 Pod 需求动态调整节点数量。&lt;/li>
&lt;li>&lt;strong>成本优化&lt;/strong>：减少闲置节点，节省云资源费用。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="3-cluster-autoscaler-的工作原理">&lt;strong>3. Cluster Autoscaler 的工作原理&lt;/strong> &lt;a href="#3-cluster-autoscaler-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h2>&lt;h3 id="1触发扩容的条件">&lt;strong>（1）触发扩容的条件&lt;/strong> &lt;a href="#1%e8%a7%a6%e5%8f%91%e6%89%a9%e5%ae%b9%e7%9a%84%e6%9d%a1%e4%bb%b6" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;ul>
&lt;li>当 Kubernetes 调度器（Scheduler）发现 &lt;strong>Pending Pod&lt;/strong>（因资源不足无法调度的 Pod）时，Cluster Autoscaler 会检查：
&lt;ul>
&lt;li>是否有合适的节点池（Node Pool）可以扩容。&lt;/li>
&lt;li>扩容后是否能满足 Pod 的资源需求（CPU、内存等）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2触发缩容的条件">&lt;strong>（2）触发缩容的条件&lt;/strong> &lt;a href="#2%e8%a7%a6%e5%8f%91%e7%bc%a9%e5%ae%b9%e7%9a%84%e6%9d%a1%e4%bb%b6" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;ul>
&lt;li>当节点 &lt;strong>长时间利用率过低&lt;/strong>（默认低于 50%）时，Cluster Autoscaler 会尝试缩容：
&lt;ul>
&lt;li>检查节点上的 Pod 是否可以被安全迁移（如使用 &lt;code>PodDisruptionBudget&lt;/code> 保护关键应用）。&lt;/li>
&lt;li>确保缩容不会导致其他节点过载。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="3与云厂商的交互">&lt;strong>（3）与云厂商的交互&lt;/strong> &lt;a href="#3%e4%b8%8e%e4%ba%91%e5%8e%82%e5%95%86%e7%9a%84%e4%ba%a4%e4%ba%92" class="anchor" aria-hidden="true">&lt;i class="material-icons align-middle">link&lt;/i>&lt;/a>&lt;/h3>&lt;p>Cluster Autoscaler 通过调用 &lt;strong>云厂商的 API&lt;/strong>（如 AWS ASG、Azure VMSS、GCP MIG）调整节点数量：&lt;/p></description></item></channel></rss>